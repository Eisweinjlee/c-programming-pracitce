## 3. 线性表

### 3.1 什么是线性表？
**线性表**：由零个或以上的元素组成的有限序列。
- 线性表中存在多个元素时，所有元素都有**前驱元素**和**后驱元素**，除了第一个元素无前驱，最后一个元素无后驱。
- 线性表是有限的，而且允许有空表（即元素个数为0）。

### 3.2 抽象数据类型
**数据类型**就是所有相同性质的值的集合，以及定义在这类值的操作的总称。例如，原子类型（整型、浮点型、字符型）、结构类型（若干个类型的组合）就是数据类型。数据类型更注重在计算机中如何存放。

**抽象类型**是指一个数学模型和定义在模型上的一系列操作。抽象数据类型更关注的是数据间的逻辑关系，并不注重在计算机中的存放方法。

**抽象数据类型标准表达**

    ADT 抽象数据类型名
    Data
	    数据元素之间的逻辑关系
	Operation
		可用操作
	endADT

**线性表的抽象定义**
```
ADT List
Data
    数据 D = {a[i] | i = 1,2, ... ,n};
	关系 R = {<a[i-1],a[i]> | a[i-1],a[i] in D}
Operation
	initList(&L); // 初始化
	destroyList(&L); // 销毁
	ListInsert(&L); // 插入元素
	ListDelete(&L); // 删除元素
	...
endADT
```

### 3.3 线性表的基本操作
-   InitList(&L)  
    构造一个空的线性表L，分配内存空间。
    
-   DestroyList(&L)  
销毁线性表L，释放空间。

-   ClearList(&L)  
将线性表L重置为空表，置0。

-   ListEmpty(L)  
    若线性表L为空表（n=0），则返回TURE；否则返回FALSE。
    
-   ListLength(L)  
    返回线性表L中的数据元素个数。
    
-  GetElem(L,i,&e)
	用e返回线性表L中第i个数据元素的值。
	
-  LocateElem(L,e)
返回线性表L中e的数据元素的位序，若不存在返回0。

- ListDelete(&L,i,&e)
取1<=i<=ListLength(L) 删除L的第i个数据元素，并用e返回其值，L的长度减一。

- ListInsert(&L,i,e)  
取1<=i<=ListLength(L)+1，在L的第i个位置之前插入新的数据元素e，L的长度加一。

### 3.4 线性表的顺序存储结构
线性表的顺序表示又称为**顺序存储结构**或**顺序映像**。  
**顺序存储定义**：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。  
顺序表的第一个数据元素的存储位置称为**起始位置**或**基地址**。依次存储，地址连续，中间没有空的存储单元。

一般在计算机中，顺序表的存储是占用一片连续的存储空间。所以我们只需要知道某个元素的存储顺序和地址，就可以知道全部元素的地址。

在C语言中，最简单的实现方法就是利用数组。

### 3.5 线性表的链式存储结构
链式存储结构，即用随意的**物理位置**来存放线性表的元素，**逻辑位置**利用一定方法保持线性顺序。

链式存储结构的相关概念：

 - **结点**：数据元素的存储结构单元，由**数据域**和**指针域**组成。
 - **链表**：结点依次相连组成一个链表。
 - **单链表、双链表、循环链表、静态链表**：结点指针域只有一个指针，单向地指向下一个结点的链表，称为**单链表**；如果结点有两个指针，分别指向上一个和下一个结点，连成**双链表**；链表收尾相连，形成一个环状链表，称为**循环链表**；用数组结构来仿造一个固定大小的链表，利用可以改变的游标来改变数组中数据的逻辑顺序，这种链表叫**静态链表**。
 - **头指针、头结点、首元结点**：链表中第一个结点中的指针，称为**头指针**；链表中第一个不保存数据，保存了头指针的结点，称为**头结点**；链表中，头指针指向的第一个存放了数据的结点，称为**首元结点**。

### 3.6 单链表
单链表一般有两种，带有头结点的，或者不带头结点（只有头指针）。单链表最后一个结点的指针指向NULL。

单链表结点的定义：

    typedef struct Lnode{
	    ElemType data; //数据域
	    struct Lnode* next; //指针域
	} Lnode, *LinkList;
	//Linklist为指向结点的指针

单链表的操作：
- InitList(Linklist *L) 初始化
- IsEmpty(Linklist L) 是否为空
- DestroyList(Linklist *L) 销毁单链表（全部清空）
- ClearList(Linklist *L) 清空单链表（头结点保留）
- ListLength(Linklist L) 求单链表长度
- List(Linklist L, int i, Elemtype *e) 读出第i元素
- LocateElem(Linklist L, Elemtype e) 按值查找
- ListInsert(Linklist *L, int i, Elemtype e) 在第i位置插入e
- ListDelete(Linklist *L, int i, Elemtype *e) 删除第i结点，并提出数据

特别的操作：
头插法（前插法），不断在前面插入数据，创建或延伸单链表
尾插法，索引到末尾的结点，不断在后面延伸单链表。

### 3.7 循环链表和双链表
**循环链表**是一种头尾相连的链表。
**pros**：从表中任一结点都可以索引到另一个位置。
**cons**：没有末尾的NULL指针，终止条件需要留意，可以用头指针来作为终止条件。

**双向链表**的结点仅仅比单链表多一个指针：

    typedef struct DuLnode{
	    ElemType data; //数据域
	    struct DuLnode *prior, *next; //指针域
	} DuLnode, *DuLinkList;
	//DuLinkList为指向结点的指针
注意，双向链表的操作和单链表类似，但需要重新编写，以照顾两个指针的变化。同样，双链表也可以变成循环链表，但意义不大。

### 3.8 顺序表和链表的优劣对比
（1）存储空间上：
**顺序表**：预先分配空间，有空间闲置或者溢出问题；存储密度等于1，不用为结点逻辑关系增加空间。
**链表**：动态分配空间，不会出现闲置和溢出；存储密度小于1，结点空间大于数据大小。

（2）操作时间上：
**顺序表**：存取效率高，按位置读写O(1)；插入删除效率低，需要平移表中的元素处理空位O(n)。
**链表**：存取效率低，按位置读写需要沿着链表索引O(n)；插入删除效率高，只需要处理指针O(1)。

适用的情况：
**顺序表**：表长稳定，很少插入删除，一般只读写的情况。
**链表**：长度变化不定，频繁插入删除。
