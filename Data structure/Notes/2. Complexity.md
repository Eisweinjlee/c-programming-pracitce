## 2. 时间复杂度和空间复杂度

### 2.1 算法效率
抛开计算机硬件，算法效率可以用下面的方法度量：采用的策略和方案、编译产生的代码质量、问题的输入规模、机器执行命令的速度。

考虑做一个求和1~100整数的算法：

    int i, sum=0, n=100;
    // 算法一
    for(i=1;i<=n;i++){
    sum = sum + i;
    }
	// 算法二（高斯求和）
	sum = (1+n)*n/2;
所以很明显，迭代算法要计算n次，而高斯的算法只需要计算1次。即便是计算机计算速度很快，当n很大的时候，差距也会增大。

我们研究算法的复杂度，侧重的是研究算法**随着输入规模扩大增长量**的一个抽象，而不是精确的定位需要执行多少次。无关语言、环境，只在意算法。

### 2.2 算法时间复杂度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。
假设我们的算法会因为数据增加、问题更复杂等原因而执行更多次，这个数量用n来表示，称为问题的规模。

**时间频度**：算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

**时间复杂度**：若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

简单来说，时间频度就是更朴实地计算语句频次，而时间复杂度会用一个简单的表达（辅助函数），来表达一个数量级。（因为n变无穷大的时候，有些系数就不重要了）

**推导方法：**

-   用常数1取代运行中的所有加法函数
-   在修改后的运行次数函数中，只保留最高阶项
-   如果最高阶项存在且不是1，则去除与这个项相乘的常数
-   得到的最后结果就是O的阶数

### 2.3 时间复杂度例子
#### 常数阶O(1)

    printf("Hello World!");
    sum =  (1+n)*n/2;
    printf("Hello World!");
时间频次是T(3)，时间复杂度就是O(1)。问题的规模是固定的，不会因为任何因素变化。

#### 线性阶O(n)
    for(i=1;i<=n;i++){
    sum = sum + i;}
一个执行n次的循环语句，运算时间随着n的增大而线性增大。

#### 平方阶O(n^2)
    for(i=1;i<=n;i++)
    {
	    for(j=1;j<=n;j++)
	    {
		    printf("Hello World!");
	    }
    }
两层循环嵌套，时间复杂度是O(n^2)。

#### 对数阶O(logn)
    int i=1, n=100;
    while(i<n){
	    i = i * 2;
    }
每次循环后i=i*2，执行了x次2^x >= n结束。那么运算次数近似x=log2n，随着n的增大，算法进行次数呈对数性增加。时间复杂度O(logn)。

可见，时间复杂度是一个统一简单的表达形式：
| 例子 | 时间复杂度 | 类型 |
|--|--| -- |
| 6 times | O(1) |常数阶 |
| 3n+4 | O(n) |线性阶 |
| 3n^2+4n+5 | O(n^2) |平方阶 |
| 3log2n + 4 | O(logn) |对数阶 |
| 2n+3nlog2n+14 | O(nlogn) |nlogn阶 |
| n^3 + 2n^2+4n+6 | O(n^3) | 立方阶 |
| 2^n | O(2^n) | 指数阶 |

如果有几个不同的阶次混合在一起，比较起来顺序是：
$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)  
< O(n^3)<O(2n)<O(n!)<O(n^n)$

对于包含随机状况的算法，我们常常考虑**平均时间复杂度**以及**最坏时间复杂度**，根据应用情况来考虑。比如有各类搜索算法、排序算法等等。

### 2.4 空间复杂度
时间和空间在算法上是个权衡的因素，有时候完全可以降低空间效率来换取时间效率。

举例说明：判断某一年是否为闰年。
算法1：每给一个年份，都会通过算法计算得到是否是闰年的结果。
算法2：建立一个数组，将所有年份存入结果。如果是闰年，则此数组元素对应的值为1，否则为0。

对比两个算法，第一种算法很明显节约空间，但是每一次查询都需要进行数值运算。第二种算法，虽然在内存中存了几千个数组，但是每次查询只需要一次索引即可。这就是典型的空间换时间。

同理，我们可以抽象程序存储内存空间的大小s(n)，抽象出空间复杂度S(n)=O(f(n))，这里n为问题规模。

### 2.5 结语
一般来说，提到复杂度，指的是时间复杂度。因为现今的情况下，运算效率比存储效率要求更高，换取的效益更高。
