## 6. 树
### 6.1 什么是树？
一种一对多的数据结构，例如文件目录结构。
树（Tree）是n(n>=0)个结点的有限集，当n=0时是空树。在任一一棵非空树有下面的特性：
- **有且只有一个**特定的结点，被称为根（Root）。
- 当n>1时，其余节点可以分为m（m>0）个**互不相交**的有限集T1、T2、...、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Sub Tree）。

**相关概念**

**度（degree）**：结点拥有的子树的数量称作为结点的度。
**叶结点（Leaf）**：度为0的结点称作为叶结点，或者**终端结点**。
**内部结点**：中间的不是叶结点，也不是根的就是内部结点。
**层次（Level）**：从根开始每有一层级的亲子关系，就多一层。
**深度（Depth）**：树中结点的最大层次成为树的深度。

**节点间的关系**

结点下一级的结点称作为结点的**孩子、子结点（Child）**，相应的子结点的上一级称作结点的**双亲（Parent）**，同一双亲的子结点间互为**兄弟（Sibling）**。结点的**祖先**，是该结点到根的所有结点。

**有序树**：树中的结点是有次序的，不能够被互换位置的，就称作为有序树。否则是无序树。
**森林（Forest）**：是m（m>=0）棵互不相交的树的集合。对于一个度大于等于2的结点，其子树的集合构成森林。

### 6.2 树的存储结构
不可能考虑线性表的顺序存储和链式结构。有三种方法，双亲表示法、孩子表示法、孩子兄弟表示法。

**双亲表示法**

以双亲作为索引的存储方式。在每一个结点中，附设一个指示双亲结点的位置的元素。用数组的形式表达：

    typedef struct PTNode{
	    ElemType data;
	    int parent; // 双亲的下标序号
    } PTNode;
    typedef struct {
	    PTNode nodes[MAX_TREE_SIZE];
	    int r; // 根的下标序号
	    int n; // 结点总数
	} PTree;
用数组下标序号可以，也可以用指针。索引双亲的时间复杂度O(1)，根的双亲索引到-1（或者NULL指针），就找到了根。索引孩子，需要遍历整个树结构O(n)。

**孩子表示法**

重视孩子结点，因为每个结点可能有多个子结点，所以可以用多重链表来表示。

每个结点对应数组的一个位置，如果结点没有子结点，则存一个NULL指针；如果有子结点，则指向一个链表，链表的数据存放所有子结点的序号。

**双亲孩子表示法**

孩子表示法的扩展，每个结点对应一个二维的空间，第一维保存双亲的序号，第二维保存子结点序号的链表，没有子结点就是NULL。

    // child node
    typedef  struct  CTNode{
	    int child; // the index of child node
	    struct  CTNode  *next; // the next child
    } *ChildPtr;
    
    typedef struct{
	    ElemType data; // the data saved in a node of tree
		int parent; // the index of parent of a node
		ChildPtr first_child; // the Linklist to save the children
	} CTBox;

### 6.3 二叉树

**二叉树（Binary Tree）** 几乎是使用范围最广，最有使用意义的树结构。二叉树是n（n>=0）个结点的有限集合，可以是空集（空二叉树），由一个根结点和两颗互不相交的、分别称作根结点的左子树和右子树组成，也可以没有子树或只有一棵子树，度不大于2。左子树和右子树是**有序的**，次序不可颠倒，即使树中某结点只有一颗子树，也要区分是左子树还是右子树。

**特殊的二叉树**

- **斜树**：每个结点只有一颗子树，且全部都是一个方位的子树（全是左子树或全是右子树）。
- **满二叉树**：所有分支结点都有左子树和右子树，且所有的叶都在同一层次（最下一层）。
- **完全二叉树**：特殊的满二叉树。按层序编号结点，如果i结点（1 <= i <= n）的所在位置和在满二叉树中的位置都一样，这棵树就是完全二叉树。因此，完全二叉树的叶子出现在后两层，而且最下层叶子左部连续位置一定存在，这样可以保证序号。

**二叉树的性质**

1. 在二叉树的第i层上，至多有$2^{i-1}$个结点(i>=1)。
2. 深度为k的二叉树，至多有$2^k -1$个结点(k>=1)。
3. 对任何一颗二叉树T，如果其叶结点数为$n_0$，度为2的结点数为$n_2$，则$n_0 = n_2 + 1$。
**证明：** 假设度为1的结点数$n_1$，二叉树总结点数$n=n_0+n_1+n_2$，连接数（edges）等于$n-1$，也等于$n_1+2*n_2$。可推出$n-1=n_1+2*n_2$，代入$n=n_0+n_1+n_2$得到$n_0=n_2+1$。
4. 具有n个结点的完全二叉树的深度为$floor(\log_2n)+1$，floor是向下取整数。
**证明**：根据性质2，n个结点的满二叉数$k=\log_2(n+1)$，少一层的满二叉树有$2^{k-1}-1$个结点。所以完全二叉树的结点数取值范围$2^{k-1}-1<n\le2^{k}-1$，因为n是整数，改改符号得到$2^{k-1}\le n<2^{k}$，取对数得到$k-1\le \log_2n<k$，取整$k=floor(\log_2n)+1$。
5. 具有n个结点的完全二叉树的结点按层序编号，任一结点i有以下性质：(1)如果i=1，则结点i是二叉树的艮，无双亲；如果i>1，双亲结点是floor(i/2)。(2)如果2i>n，则结点i是叶子结点，无左子树；否则左子树结点为2i。(3) 如果2i+1>n，则结点i无右子树；否则其右子树结点为2i+1。

**二叉树的存储结构**

**顺序存储结构**的时候，与完全二叉树的相容性更好。可以用**下标**来遍历二叉树，如果没有数据的话，用空数据来表示就可以了。如果是非完全二叉树，也可以用下标来表示具体的位置，过程中空的结点存入空数据。
但是，在如果是个结构松散的树，比如斜树。顺序存储结构的空间效率极低，存放的空数据多于有意义的数据。

**链式存储结构——二叉链表**，设计一个数据域和两个指针域来设计。

    typedef struct BiTNode{
	    ElemType data;
	    struct BiTNode *lchild, *rchild;
	} BiTNode, *BiTree;
所以每一个二叉链表的结点：
|*lchild| data | *rchild|
|--|--|--|

### 6.4 二叉树的遍历
**二叉树的遍历（Traversing binary tree）**是指从根结点出发，按照某种**次序**一次**访问**二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

不同于线性结构，可以简单用顺序、循环、双向这类方法遍历。树不存在唯一的前驱和后续，会面对两个方向，因此需要不同的遍历思维。以下四种思维：前序遍历、中序遍历、后序遍历、层序遍历。

- **前序遍历**：若二叉树为空则返回；否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
![前序遍历](https://user-images.githubusercontent.com/26374671/80339479-afdb9a80-8899-11ea-9e1d-81cc61feaec6.png)

- **中序遍历**：若二叉树为空则返回；否则从根结点开始（并不访问），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。（注意，图中访问A后，F没有左子树，所以访问F优先于K）
![中序遍历](https://user-images.githubusercontent.com/26374671/80339706-30020000-889a-11ea-8a53-4f92fe70d9fa.png)

- **后序遍历**：若二叉树为空则返回；否则从左到右先叶子结点的方式遍历访问左右子树，最后访问根结点。
![后序遍历](https://user-images.githubusercontent.com/26374671/80339907-95ee8780-889a-11ea-9220-0a6fd9ee4342.png)

- **层序遍历**：若二叉树为空则返回；否则从树的第一层开始，自上而下地逐层遍历，在同一层中，从左到右对每个结点逐个访问。
![层序遍历](https://user-images.githubusercontent.com/26374671/80340047-db12b980-889a-11ea-8963-e778ca90bdd3.png)

二叉树的建立和遍历算法，以前序为例：

    void  PreOrderTraverse(BiTree  T, int  level)
	{
		if(T){
			visit(T->data, level);
			PreOrderTraverse(T->lchild, level+1);
			PreOrderTraverse(T->rchild, level+1);
		}
	}
如果转换为中序后序，只需要调整`visit(T->data, level);`的位置即可。
