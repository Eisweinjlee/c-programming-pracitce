## 4. 指针
指针基本上是C语言中最重要的内容，很多灵活的C语言语法都源自于指针的特性。
本质上，在编译后的程序中，并不存在变量名，所有数据都是通过内存地址保存和读取的，因此指针就是接触底层的途径。
e.g. int num（变量名）存放于地址00010005开始的4个字节（int）。

### 4.1 指针基础
一般变量：保存定义的数据；指针变量：保存各种东西的地址。
定义：

    char a; char *pa; pa = &a; // pa保存了字符变量a的地址
    int b; int *pb; pb = &b; // pb保存了整型变量b的地址
复习两个运算符：
取址运算符&：提取某个已经定义的变量的地址。
取值运算符*：提取指针变量指向的值，例如`*pa, *pb`。
（注意，在定义的时候*不代表取值，仅代表定义指针变量）

### 4.2 指针与数组
数组名本质上就是一个指针变量，是数组中第一个数的地址。

    char str[100];
    // str = &str[0] = 一个地址值
所以要定义一个指向数组的指针直接用 `char *p; p = str;`即可，不用取地址。

因为数组是顺序存储，在索引数组中的其他元素使可以直接加地址：

    *p == str[0]; *(p+1) == str[1]; *(p+i) == str[i];
    //以上都为真，且C语言会根据数据类型跃进若干字节的地址

一个不太实用但也是可以用的，定义字符串的两个方式：

    char *str = ".....";
    char str[] = "....."; // 这两个等价
要注意的是，数组名和指针本质是不同的：数组名是只读的地址量，而指针是个可以赋值的量（左值lvalue）：

    //对于指针：
    p++; (p+1); p = &str[2]; //都是合法的
    //数组名：
    str++; (str+1); //是错误的

极其容易混淆的魔幻定义：

    int *p1[5]; int (*p2)[5];
注意，数组索引[5]优先级高于取值运算符*，但低于括号。
指针数组p1：数组p1中存放了5个指针变量，指向整型数据。
数组指针p2：指针p2指向了一个无名数组，存放了5个整型数据。

### 4.3 指针与二维数组
如第三章所说，二维数组实际上是以若干个一维数组组成。
如果定义`int array[3][5];`，那么`array`是存放`array[0]`的地址，`array[0]`存放的是`array[0][0]`的地址。
那么我们可以取值符号的方式，取值二维数组：

    array+i == &array[i];    *(array+i) == array[i];
    *(array+i)+j == array[i]+j == &array[i][j];
    *(*(array+i)+j) == *(array[i]+j) == array[i][j];

### 4.4 void指针，null指针和多重指针
void指针：通用指针，可以指向任何类型的变量，但是不能被直接解引用取值，需要强制类型转化：

    int a; 
    void *pv = &a;
    a == *(int*) pv;

null指针：空指针（一般指向0），可以用于初始化防止指针定义乱指。

    #define NULL ((void*) 0) // NULL在C的文件中的定义
    int* p = NULL; // 暂时没有变量取地址，那就指NULL完成初始化

多重指针；即指向指针变量的指针变量

    int num;
    int *p = &num; // 一重指针
    int **pp = &p; // 二重指针
    num == *p == **pp;

### 4.5 指针和数组的魔幻定义
指针数组（很实用直接存取字符串的技巧）：

    char* str = {"AAA","BBB","CCC"}; //str存三个字符串的头指针
    char** p[2] = {}; // 指针数组,可以放两个二重指针
	
	p[0] = &str[0]; p[1] = &str[1];
	printf("%s\n", *p[0]); // 输出AAA
	printf("%s\n", *p[1]); // 输出BBB

数组指针：

    int array[3][4] = {....}; 
    int (*p)[4] = array; // 数组指针
    //这样的话 p = &array[0], p+1 = &array[1]; p+2 = &array[2];
    //并且编译器可以知道, p -> p+1中间，有4个int整型变量
    printf("%d\n", *(*(p+i)+j)); // 输出array[i][j]
    
### 4.6 const常量与指针
一般来说，常量是：50（纯数字），'a'（字符常量）...也可是宏定义常量#define pi 3.14。还有一种办法让变量“只读化”，用const关键字：

    const int priceA = 520;
    const char score = 'A';
这样的话就不能再赋值给它们了，指针定义也变成：

    const int num = 123;	int num2 = 666;
    
    const int* pnum = &num; // const不能少，编译器报错
    *pnum = 250; // 报错！因为pnum只向一个const int
    pnum = &num2; // 合法！const int*可以变向指别的
    
    int* const cpnum = &num2; // 指针被只读化，不能改变指向
    // 但可以通过num2改变*pcnum的取值
    
    const int* const cpcnum = &num; // num是只读，cpcnum也只读
    // 十分保险无法给改变num的值，也改不了cpcnum的指向

